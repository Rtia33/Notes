<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [【JAVA 类的加载机制】](#java-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6)
- [类加载机制概念](#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%A6%82%E5%BF%B5)
- [工作机制](#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6)
  - [1. 装载(加载)](#1-%E8%A3%85%E8%BD%BD%E5%8A%A0%E8%BD%BD)
    - [什么是类的装载](#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E8%A3%85%E8%BD%BD)
      - [加载.class文件的方式有:](#%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89)
    - [jvm进行类加载阶段都做了什么。](#jvm%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88)
      - [1）通过一个类的全限定名称来获取定义此类的二进制字节流。](#1%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D%E7%A7%B0%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AE%9A%E4%B9%89%E6%AD%A4%E7%B1%BB%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81)
      - [2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。](#2%E5%B0%86%E8%BF%99%E4%B8%AA%E5%AD%97%E8%8A%82%E6%B5%81%E6%89%80%E4%BB%A3%E8%A1%A8%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
      - [3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。](#3%E5%9C%A8java%E5%A0%86%E4%B8%AD%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E4%BB%A3%E8%A1%A8%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%9A%84javalangclass%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8C%BA%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E5%85%A5%E5%8F%A3)
- [RT](#rt)
  - [2. 验证](#2-%E9%AA%8C%E8%AF%81)
    - [1）文件格式的验证：](#1%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%AA%8C%E8%AF%81)
    - [2）元数据验证：](#2%E5%85%83%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81)
    - [3）字节码验证：](#3%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81)
    - [4）符号引用验证：](#4%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81)
  - [3. 准备](#3-%E5%87%86%E5%A4%87)
  - [4. 解析](#4-%E8%A7%A3%E6%9E%90)
    - [1）类或接口(对应于常量池的CONSTANT_Class_info类型)的解析：](#1%E7%B1%BB%E6%88%96%E6%8E%A5%E5%8F%A3%E5%AF%B9%E5%BA%94%E4%BA%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84constant_class_info%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%A3%E6%9E%90)
    - [2）字段(对应于常量池的CONSTANT_Fieldref_info类型)解析：](#2%E5%AD%97%E6%AE%B5%E5%AF%B9%E5%BA%94%E4%BA%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84constant_fieldref_info%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90)
    - [3）类方法(对应于常量池的CONSTANT_Methodref_info类型)解析：](#3%E7%B1%BB%E6%96%B9%E6%B3%95%E5%AF%B9%E5%BA%94%E4%BA%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84constant_methodref_info%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90)
    - [4）接口方法(对应于常量池的CONSTANT_InterfaceMethodref_info类型)解析：](#4%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E5%AF%B9%E5%BA%94%E4%BA%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84constant_interfacemethodref_info%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90)
  - [5. 初始化](#5-%E5%88%9D%E5%A7%8B%E5%8C%96)
    - [类初始化的触发条件:](#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6)
      - [(1)遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。](#1%E9%81%87%E5%88%B0newgetstaticputstatic%E6%88%96invokestatic%E8%BF%994%E6%9D%A1%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E6%97%B6%E5%A6%82%E6%9E%9C%E7%B1%BB%E6%B2%A1%E6%9C%89%E8%BF%9B%E8%A1%8C%E8%BF%87%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%99%E9%9C%80%E8%A6%81%E5%85%88%E8%A7%A6%E5%8F%91%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96)
      - [(2) 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。](#2-%E4%BD%BF%E7%94%A8javalangreflect%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95%E5%AF%B9%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C%E7%B1%BB%E6%B2%A1%E6%9C%89%E8%BF%9B%E8%A1%8C%E8%BF%87%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%99%E9%9C%80%E8%A6%81%E5%85%88%E8%A7%A6%E5%8F%91%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96)
      - [(3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。](#3-%E5%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E5%85%B6%E7%88%B6%E7%B1%BB%E8%BF%98%E6%B2%A1%E6%9C%89%E8%BF%9B%E8%A1%8C%E8%BF%87%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%99%E9%9C%80%E8%A6%81%E5%85%88%E8%A7%A6%E5%8F%91%E5%85%B6%E7%88%B6%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96)
      - [(4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。](#4-%E5%BD%93%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%97%B6%E7%94%A8%E6%88%B7%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%BB%E7%B1%BB%E5%8C%85%E5%90%ABmain%E6%96%B9%E6%B3%95%E7%9A%84%E9%82%A3%E4%B8%AA%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BC%9A%E5%85%88%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%99%E4%B8%AA%E4%B8%BB%E7%B1%BB)
    - [JVM初始化步骤](#jvm%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4)
    - [初始化阶段时执行类构造器()方法的过程](#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E6%97%B6%E6%89%A7%E8%A1%8C%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B)
- [结束生命周期](#%E7%BB%93%E6%9D%9F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)
    - [1. 执行了System.exit()方法](#1-%E6%89%A7%E8%A1%8C%E4%BA%86systemexit%E6%96%B9%E6%B3%95)
    - [2. 程序正常执行结束](#2-%E7%A8%8B%E5%BA%8F%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F)
    - [3. 程序在执行过程中遇到了异常或错误而异常终止](#3-%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E4%BA%86%E5%BC%82%E5%B8%B8%E6%88%96%E9%94%99%E8%AF%AF%E8%80%8C%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2)
    - [4. 由于操作系统出现错误而导致Java虚拟机进程终止](#4-%E7%94%B1%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E8%80%8C%E5%AF%BC%E8%87%B4java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2)
- [参考资料](#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->



# 【JAVA 类的加载机制】
在开始正文之前，我们先看两张图
先看一下java程序的执行流程图
![java程序的执行流程图](http://upload-images.jianshu.io/upload_images/9028834-35d1d28aa808fbaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

再看一下jvm的大致物理结构图
![jvm大致结构图](http://upload-images.jianshu.io/upload_images/9028834-48978db6d0f4cdd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这篇文章只会涉及到这两张图里的一部分，并不设计全部内容，对这两张图要有一个大致的印象。

# 类加载机制概念

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。

Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：**加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（using）、和卸载（Unloading）七个阶段。**其中验证、准备和解析三个部分统称为连接（Linking），这七个阶段的发生顺序如下图所示：
![](http://upload-images.jianshu.io/upload_images/9028834-a7c56f764b331df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


# 工作机制

类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：
>(1) 装载：查找和导入Class文件；
>(2) 链接：把类的二进制数据合并到JRE中；
>　(a)校验：检查载入Class文件数据的正确性；
>　(b)准备：给类的静态变量分配存储空间；
>　(c)解析：将符号引用转成直接引用；
>(3) 初始化：对类的静态变量，静态代码块执行初始化操作
>Java程序可以动态扩展是由运行期动态加载和动态链接实现的；比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)

如上图所示，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而**解析阶段则不一定，它在某些情况下可以在初始化阶段后再开始**。
类的生命周期的每一个阶段通常都是互相交叉混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。

## 1. 装载(加载)

### 什么是类的装载

类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。
类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
![](http://upload-images.jianshu.io/upload_images/9028834-ad1abf9e24c8460c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

#### 加载.class文件的方式有:
1. 从本地系统中直接加载
2. 通过网络下载.class文件
3. 从zip，jar等归档文件中加载.class文件
4. 从专有数据库中提取.class文件
5. 将Java源文件动态编译为.class文件

### jvm进行类加载阶段都做了什么。
虚拟机需要完成以下三件事情：
#### 1）通过一个类的全限定名称来获取定义此类的二进制字节流。 
#### 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
#### 3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。 

相对于类加载过程的其他阶段，加载阶段是开发期相对来说可控性比较强，该阶段**既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。**关于这个过程的更多细节，我会在下一节细说，类的加载。

加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
# RT
## 2. 验证
验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。
### 1）文件格式的验证：
验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是**保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储**，后面的三个验证都是基于方法区的存储结构进行的。 

### 2）元数据验证：
对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），**保证不存在不符合Java语法规范的元数据信息**。

### 3）字节码验证：
该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以**保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为**。 
### 4）符号引用验证：
这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 

## 3. 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。
注：
1）这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 
2）这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

## 4. 解析
虚拟机将常量池内的符号引用替换为直接引用的过程。
>**符号引用**（Symbolic Reference）：
>以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。 
>**直接引用**（Direct Reference） ：
>可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。 

### 1）类或接口(对应于常量池的CONSTANT_Class_info类型)的解析：
判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 
```
假设当前代码所处的类为D，需要将一个从未解析过的符号引用N解析为一个类或接口C的直接引用：
如果C不是一个数组类型，虚拟机将会把代表C的全限定名传递给D的类加载器去加载这个类。
如果C是一个数组类型，并且数组的元素类型为对象(N的描述符类似[Ljava.lang.Integer)，将会加载数组元素类型(java.lang.Integer)，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
如果以上过程没有发生异常，则C在虚拟机中已经成为了一个有效的类和接口了，之后还要进行的是符号引用验证，确认D是否具有对C的访问权限，如果没有，将抛出java.lang.IllegalAccessError异常。
```

### 2）字段(对应于常量池的CONSTANT_Fieldref_info类型)解析：
对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 
```
对字段表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个字段所属的类或接口。
如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。
否则，如果C实现了接口，则会按照继承关系从下往上递归搜索各个接口和他的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。
否则，如果C不是java.lang.Object类型的话，将会按照继承关系从下往上递归的搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。
否则，查找失败，抛出java.lang.NoSuchFieldError异常。

虚拟机的编译器实现可能会更严格：如果一个同名字段同时出现在C实现的接口和父类中，或者同时在自己或父类的多个接口中出现，编译器将可能拒绝编译。
```

### 3）类方法(对应于常量池的CONSTANT_Methodref_info类型)解析：
对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 
```
对方法表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个方法所属的类或接口。
类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，则抛出java.lang.IncompatibleClassChangeError。
在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。
否则，在C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。
否则，在C实现的接口列表及它们的父接口中递归的查找是否有简单名称和描述符都与目标相匹配的方法，如果有说明C是个抽象类，查找结束，抛出java.lang.AbstractMethodError异常。
否则，查找失败，抛出java.lang.NoSuchMethodError异常。
如果查找返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对这个方法的访问权限，则抛出java.lang.IllegalAccessError异常。
```

### 4）接口方法(对应于常量池的CONSTANT_InterfaceMethodref_info类型)解析：
与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。 
```
对方法表中的class_index项中索引的CONSTANT_Class_info符号引用进行解析。用C表示这个方法所属的类或接口。
如果在接口方法表中发现class_index中索引的C是个类，则抛出java.lang.IncompatibleClassChangeError。
否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。
否则，在接口C的父接口中递归查找，知道java.lang.Object类(包括在内)，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。
否则，查找失败，抛出java.lang.NoSuchMethodError。
```

## 5. 初始化
类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。
初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

在Java中对类变量进行初始值设定有两种方式：
①声明类变量时指定初始值
②使用静态代码块为类变量指定初始值

### 类初始化的触发条件:
有且只有以下四种情况必须立即对类进行”初始化”(称为对一个类进行**主动引用**)：
#### (1)遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。

#### (2) 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

#### (3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

#### (4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

只有上述四种情况会触发初始化，也称为对一个类进行**主动引用**，除此以外，所有其他方式都不会触发初始化，称为**被动引用**。

>关于上面的这四种说法，换一种通俗的解释应该对应下面的六种:
>(1) 创建类的实例，也就是new的方式
>(2) 访问某个类或接口的静态变量，或者对该静态变量赋值
>(3) 调用类的静态方法
>(4) 反射（如Class.forName(“com.shengsiyuan.Test”)）
>(5) 初始化某个类的子类，则其父类也会被初始化
>(6) Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类

>**被动引用**：
>(1) 通过子类引用父类的静态字段，不会导致子类初始化(对于静态字段，只有直接定义这个字段的类才会被初始化)。
>(2) 通过数组定义类应用类：ClassA [] array=new ClassA[10]。触发了一个名为[LClassA的类的初始化，它是一个由虚拟机自动生成的、直接继承于Object的类，创建动作由字节码指令newarray触发。
>(3) 常量会在编译阶段存入调用类的常量池。

### JVM初始化步骤
1、假如这个类还没有被加载和连接，则程序先加载并连接该类
2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
3、假如类中有初始化语句，则系统依次执行这些初始化语句

### 初始化阶段时执行类构造器()方法的过程
编译器会为接口生成<clinit>()构造器，用于初始化接口中定义的成员变量。一个接口在初始化时，并不要求其父类接口全部完成了初始化，只有在真正使用到父接口的时候才会初始化。

1）<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。 

2）<clinit>()方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕，因此在虚拟机中第一个执行的<clinit>()方法的类一定是java.lang.Object。 

3）由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。 

4）<clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。 

5）接口中可能会有变量赋值操作，因此接口也会生成<clinit>()方法。但是接口与类不同，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的<clinit>()方法。 

6）虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其它线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。


# 结束生命周期
在以下情况的时候，Java虚拟机会结束生命周期
### 1. 执行了System.exit()方法
### 2. 程序正常执行结束
### 3. 程序在执行过程中遇到了异常或错误而异常终止
### 4. 由于操作系统出现错误而导致Java虚拟机进程终止

# 参考资料
[http://www.cnblogs.com/ityouknow/p/5603287.html](http://www.cnblogs.com/ityouknow/p/5603287.html)
[http://smallbug-vip.iteye.com/blog/2275284](http://smallbug-vip.iteye.com/blog/2275284)
[http://www.cnblogs.com/ITtangtang/p/3978102.html](http://www.cnblogs.com/ITtangtang/p/3978102.html)
[http://blog.csdn.net/gjanyanlig/article/details/6818655](http://blog.csdn.net/gjanyanlig/article/details/6818655)

引用：
[深入理解类加载机制](http://hammer.coding.me/2016/10/26/jvm-1/)
 [Java虚拟机类加载机制](http://www.cnblogs.com/yshb/archive/2012/11/05/2756194.html)



